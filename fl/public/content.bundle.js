/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./public/content.js":
/*!***************************!*\
  !*** ./public/content.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXT_ID: () => (/* binding */ EXT_ID)\n/* harmony export */ });\n/* harmony import */ var _loadPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loadPage */ \"./public/loadPage.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./public/utils.js\");\n\n\nconst EXT_ID = \"FL - 2024.08.22-1\";\nconst ALBUMS_PATH = \".view .sub-photo-title-desc-view\";\nconst ALBUMS_DIV = \"div_rg_1\";\n(0,_utils__WEBPACK_IMPORTED_MODULE_1__.log)(\"before start\", document.readyState);\nif (document.readyState != 'complete') {\n  document.onload = document.onreadystatechange = start;\n} else {\n  start();\n}\n(0,_utils__WEBPACK_IMPORTED_MODULE_1__.log)(\"after start\");\n//=====================================================================\nfunction start() {\n  (0,_utils__WEBPACK_IMPORTED_MODULE_1__.log)(\"start\");\n  if (!document.readyState || document.readyState == 'complete') {\n    checkPhotostream();\n    checkPhoto();\n    ones();\n  }\n  ;\n  document.addEventListener('keyup', doc_keyUp, false);\n}\nfunction ones() {\n  (0,_utils__WEBPACK_IMPORTED_MODULE_1__.log)(document.location.hostname);\n  if (!document.location.hostname.endsWith(\"ones.com\")) {\n    return;\n  }\n  if (document.location.href.endsWith(\"/feed\")) {\n    const aurl = document.location.href.replace(\"/feed\", \"/photos?q=&f[categories]=Anal&filter_mode[categories]=and&filter_mode[global]=and\");\n    const furl = document.location.href.replace(\"/feed\", \"/photos?q=&f[categories]=Facial&filter_mode[categories]=and&filter_mode[global]=and\");\n    const win2 = window.open(aurl, \"_blank\");\n    const win1 = window.open(furl, \"_blank\");\n    // window.close()\n    // document.location.href = aurl\n  } else {\n    const gallery = document.querySelectorAll(\"#fxgp-gallery > figure:nth-child(1) > a\")[0];\n    if (!gallery) {\n      (0,_utils__WEBPACK_IMPORTED_MODULE_1__.log)(\"no gallery\");\n      return;\n    }\n    gallery.click();\n  }\n}\nfunction doc_keyUp(e) {\n  (0,_utils__WEBPACK_IMPORTED_MODULE_1__.log)(e);\n  if (e.ctrlKey && e.altKey && e.key === 'a') {\n    openAlbums();\n  }\n  if (e.ctrlKey && e.altKey && e.key === 'x') {\n    openPhotostream();\n  }\n  if (e.ctrlKey && e.altKey && e.key === 'ArrowRight') {\n    nextPage();\n  }\n  if (e.ctrlKey && e.altKey && e.key === 'ArrowLeft') {\n    previousPage();\n  }\n  if (e.ctrlKey && e.altKey && e.key === 'z') {\n    openAbout();\n  }\n  if (e.ctrlKey && e.altKey && e.keyCode >= 48 && e.keyCode <= 57) {\n    openPhoto(e.keyCode - 48);\n  }\n}\nfunction openPhoto(pos) {\n  console.log(\"openPhoto()\", pos);\n  const photos = document.querySelectorAll(\".photo-list-photo-interaction > a\");\n  if (photos.length > pos) {\n    const photo = photos[pos - 1];\n    photo.click();\n  }\n}\nfunction previousPage() {\n  var _a;\n  (_a = document.querySelector(\"a[data-track='paginationLeftClick']\")) === null || _a === void 0 ? void 0 : _a.click();\n}\nfunction nextPage() {\n  var _a;\n  (_a = document.querySelector(\"a[data-track='paginationRightClick']\")) === null || _a === void 0 ? void 0 : _a.click();\n}\nfunction openAbout() {\n  var _a;\n  // console.log(\"openAbout()\");\n  const about = (_a = document.querySelector(\"li#about > a\")) === null || _a === void 0 ? void 0 : _a.href;\n  console.log(about);\n  if (about) {\n    document.location.href = about;\n  }\n}\nfunction openAlbums() {\n  // console.log(\"openAlbums()\");\n  const albums = document.querySelector(\"#\" + ALBUMS_DIV).querySelectorAll(\"a.thumbnail\");\n  if (albums.length == 0) {\n    return;\n  }\n  if (albums.length == 1) {\n    const album = albums[0];\n    document.location.href = album.href;\n  } else {\n    Array.from(albums).forEach(a => (0,_utils__WEBPACK_IMPORTED_MODULE_1__.openTab)(a.href));\n  }\n}\nfunction openPhotostream() {\n  var _a;\n  const photostream = (_a = document.querySelector(\".attribution-info > a.owner-name.truncate\")) === null || _a === void 0 ? void 0 : _a.href;\n  if (photostream) {\n    document.location.href = photostream;\n  }\n}\nfunction checkPhotostream() {\n  if (document.location.href !== \"https://www.flickr.com/\") {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.log)(\"No Photostream\");\n    return;\n  }\n  const targetNode = document.querySelector(\".flickr-logo-container\");\n  if (!targetNode) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.log)(\"no logo\");\n    setTimeout(checkPhotostream, 100);\n    return;\n  }\n  addUI(targetNode);\n}\nfunction checkPhoto() {\n  if (!document.location.href.startsWith(\"https://www.flickr.com/photos/\")) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.log)(\"No Photo\");\n    return;\n  }\n  const targetNode = document.querySelector(ALBUMS_PATH);\n  if (!targetNode) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.log)(\"No Photo found\");\n    setTimeout(checkPhoto, 100);\n    return;\n  }\n  const d1 = document.createElement(\"DIV\");\n  d1.id = ALBUMS_DIV;\n  document.body.appendChild(d1);\n  const width = 200;\n  const left = screen.width - width - 17;\n  const top = 50;\n  const height = screen.height - top;\n  d1.style.position = \"absolute\";\n  d1.style.top = top + \"px\";\n  d1.style.height = height + \"px\";\n  d1.style.width = width + \"px\";\n  d1.style.left = left + \"px\";\n  d1.style.backgroundColor = \"black\";\n  d1.style.zIndex = \"10000\";\n  d1.appendChild(targetNode);\n  targetNode.style.backgroundColor = \"white\";\n  targetNode.style.margin = \"0\";\n  checkAlbum(d1);\n}\nfunction checkAlbum(d1) {\n  const targetNode = document.querySelector(\".view .sub-photo-albums-view\");\n  if (!targetNode) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.log)(\"No Photo found\");\n    setTimeout(() => {\n      checkAlbum(d1);\n    }, 100);\n    return;\n  }\n  d1.appendChild(targetNode);\n  targetNode.style.backgroundColor = \"white\";\n  //\ttargetNode.style.marginTop = \"0px\"\n}\nfunction addUI(targetNode) {\n  if (!targetNode || !targetNode.parentNode) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.log)(\"targetNode or targetNode.parentNode not found\", targetNode);\n    return;\n  }\n  var loadButton = document.createElement(\"INPUT\");\n  loadButton.type = \"button\";\n  loadButton.id = \"rg-fli-load\";\n  loadButton.value = \"Load\";\n  loadButton.addEventListener(\"click\", load);\n  targetNode.parentNode.insertBefore(loadButton, targetNode.nextSibling);\n  targetNode.parentNode.insertBefore(document.createTextNode(\"&nbsp;\"), targetNode.nextSibling);\n  var scrollButton48 = document.createElement(\"INPUT\");\n  scrollButton48.type = \"button\";\n  scrollButton48.id = \"rg-fli-scroll\";\n  scrollButton48.value = \"Scroll Free\";\n  scrollButton48.addEventListener(\"click\", scrollStartFree);\n  targetNode.parentNode.insertBefore(scrollButton48, targetNode.nextSibling);\n  targetNode.parentNode.insertBefore(document.createTextNode(\"&nbsp;\"), targetNode.nextSibling);\n  var scrollButton = document.createElement(\"INPUT\");\n  scrollButton.type = \"button\";\n  scrollButton.id = \"rg-fli-scroll\";\n  scrollButton.value = \"Scroll 24\";\n  scrollButton.addEventListener(\"click\", () => {\n    scrollStart(24);\n  });\n  targetNode.parentNode.insertBefore(scrollButton, targetNode.nextSibling);\n  targetNode.parentNode.insertBefore(document.createTextNode(\"&nbsp;\"), targetNode.nextSibling);\n  var scroll12Button = document.createElement(\"INPUT\");\n  scroll12Button.type = \"button\";\n  scroll12Button.id = \"rg-fli-scroll12\";\n  scroll12Button.value = \"Scroll 12\";\n  scroll12Button.addEventListener(\"click\", () => {\n    scrollStart(12);\n  });\n  targetNode.parentNode.insertBefore(scroll12Button, targetNode.nextSibling);\n  targetNode.parentNode.insertBefore(document.createTextNode(\"&nbsp;\"), targetNode.nextSibling);\n  var loadPageButton = document.createElement(\"INPUT\");\n  loadPageButton.type = \"button\";\n  loadPageButton.id = \"rg-fli-loadPage\";\n  loadPageButton.value = \"Load Page\";\n  loadPageButton.addEventListener(\"click\", _loadPage__WEBPACK_IMPORTED_MODULE_0__.loadPage);\n  targetNode.parentNode.insertBefore(loadPageButton, targetNode.nextSibling);\n  targetNode.parentNode.insertBefore(document.createTextNode(\"&nbsp;\"), targetNode.nextSibling);\n  (0,_utils__WEBPACK_IMPORTED_MODULE_1__.log)(\"addUI done\");\n}\nfunction getHours() {\n  var _a;\n  const times = document.querySelectorAll(\".time\");\n  let lastTime = (_a = times[times.length - 1].textContent) === null || _a === void 0 ? void 0 : _a.trim();\n  if (!lastTime) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.log)(\"no lastTime\");\n    return 0;\n  }\n  console.log(\"scroll: \", lastTime);\n  let hours = 0;\n  if (lastTime.endsWith(\"ago\")) {\n    lastTime = lastTime.substr(0, lastTime.length - 4);\n    let multi = 1;\n    if (lastTime.endsWith(\"d\")) {\n      multi = 24;\n    }\n    hours = parseInt(lastTime.substring(0, lastTime.length - 1)) * multi;\n  } else {\n    if (lastTime === \"1 g. fa\") {\n      hours = 24;\n    }\n    if (lastTime === \"2 gg. fa\") {\n      hours = 48;\n    }\n  }\n  console.log(\"scroll: \", hours);\n  return hours;\n}\nclass Scroller {\n  constructor(tillHours) {\n    this.tillHours = tillHours;\n  }\n  scroll() {\n    const hours = getHours();\n    console.log(\"tillHours: \", this.tillHours);\n    if (hours >= this.tillHours) {\n      return;\n    }\n    window.scrollBy(0, 800);\n    setTimeout(() => {\n      this.scroll();\n    }, 100);\n  }\n}\nfunction scrollStart(tillHours) {\n  const scroller = new Scroller(tillHours);\n  scroller.scroll();\n}\nfunction scrollStartFree() {\n  let ris = null;\n  while (!ris) {\n    ris = prompt(\"Till Hours\", \"48\");\n  }\n  const tillHours = parseInt(ris);\n  const scroller = new Scroller(tillHours);\n  scroller.scroll();\n}\nfunction load() {\n  const urls = document.querySelectorAll(\".title-container > a\");\n  // log(urls);\n  // const uniqueUrls = [...new Set(Array.from(urls).map(a => a.href))]\n  const uniqueUrls = Array.from(new Set(Array.from(urls).map(a => a.href)));\n  (0,_utils__WEBPACK_IMPORTED_MODULE_1__.log)(\"uniqueUrls\", uniqueUrls);\n  //Array.from(uniqueUrls).forEach(a => window.open(a)); \n  const STEP = 20;\n  const blocks = [];\n  let from = 0;\n  while (true) {\n    let to = Math.min(from + STEP, uniqueUrls.length);\n    blocks.push(uniqueUrls.slice(from, to));\n    if (to == uniqueUrls.length) {\n      break;\n    }\n    from += STEP;\n  }\n  (0,_utils__WEBPACK_IMPORTED_MODULE_1__.log)(\"blocks\", blocks);\n  blocks.forEach((b, i) => createBlock(b, i));\n}\nfunction createBlock(urls, pos) {\n  (0,_utils__WEBPACK_IMPORTED_MODULE_1__.log)(\"createBlock\", urls, pos);\n  const targetNode = document.querySelector(\"#rg-fli-load\");\n  if (!targetNode || !targetNode.parentNode) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.log)(\"targetNode or targetNode.parentNode not found\", targetNode);\n    return;\n  }\n  var blockButton = document.createElement(\"INPUT\");\n  blockButton.type = \"button\";\n  blockButton.id = \"rg-fli-block-\" + pos;\n  blockButton.value = \"Block \" + (pos + 1);\n  blockButton.style.backgroundColor = 'red';\n  blockButton.addEventListener(\"click\", () => {\n    loadBlock(blockButton, urls);\n  });\n  targetNode.parentNode.insertBefore(blockButton, targetNode);\n  targetNode.parentNode.insertBefore(document.createTextNode(\"&nbsp;\"), targetNode);\n}\nfunction loadBlock(source, urls) {\n  (0,_utils__WEBPACK_IMPORTED_MODULE_1__.log)(\"loadBlock\", urls);\n  source.style.backgroundColor = 'green';\n  urls.forEach(a => window.open(a));\n}\n\n//# sourceURL=webpack:///./public/content.js?");

/***/ }),

/***/ "./public/loadPage.js":
/*!****************************!*\
  !*** ./public/loadPage.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loadPage: () => (/* binding */ loadPage)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./public/utils.js\");\n/* harmony import */ var mustache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mustache */ \"./node_modules/mustache/mustache.mjs\");\nvar __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\n\nconst FOR_PAGE = 12;\nconst LIMIT_TO = -1;\n// const LIMIT_TO = 4\nconst sleep = ms => new Promise(r => setTimeout(r, ms));\nfunction loadPage() {\n  return __awaiter(this, void 0, void 0, function* () {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.log)(\"loadPage\");\n    const tables = {};\n    const cells = {};\n    const buttons = document.querySelectorAll(\"a.count-overlay-button\");\n    // log(buttons)\n    Array.from(buttons).forEach(b => {\n      b.click();\n    });\n    yield sleep(5000);\n    const urls = document.querySelectorAll(\"div.photo > a.photo-link\");\n    const uniqueUrls = Array.from(new Set(Array.from(urls).map(a => a.href)));\n    // log(uniqueUrls);\n    let pages = slice(uniqueUrls.slice(0, LIMIT_TO), FOR_PAGE);\n    pages.forEach(urlsForPage => loadFinalPage(urlsForPage));\n  });\n}\nfunction loadFinalPage(urls) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // log(\"loadFinalPage\", urls)\n    let images = [];\n    for (const url of Array.from(urls)) {\n      images.push(yield getImageInfo(url));\n    }\n    const win = window.open(\"about:blank\", \"_blank\");\n    const doc = win.document;\n    const style = doc.createElement('style');\n    style.innerHTML = getNewStyle();\n    doc.head.appendChild(style);\n    const target = doc.createElement(\"div\");\n    doc.body.insertBefore(target, doc.body.childNodes[0]);\n    render(target, images);\n  });\n}\nfunction fill(template, target, images) {\n  const rendered = mustache__WEBPACK_IMPORTED_MODULE_1__[\"default\"].render(template, {\n    images: images\n  });\n  // log(rendered)\n  target.innerHTML = rendered;\n}\nfunction slice(array, chunkSize) {\n  const ris = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    const chunk = array.slice(i, i + chunkSize);\n    ris.push(chunk);\n  }\n  return ris;\n}\nfunction getImageInfo(url) {\n  return __awaiter(this, void 0, void 0, function* () {\n    var _a, _b, _c, _d, _e, _f;\n    // log(\"getImageInfo - start\", url)\n    const ris = yield fetch(url);\n    const html = yield ris.text();\n    // log(html)\n    const parser = new DOMParser();\n    const doc = parser.parseFromString(html, \"text/html\");\n    const photostream = doc.querySelector(\"div.attribution-info > a\");\n    if (photostream == null) {\n      (0,_utils__WEBPACK_IMPORTED_MODULE_0__.log)(\"not found stream\");\n    }\n    const photostreamName = photostream.textContent;\n    const photostreamURL = photostream.href;\n    const videos = doc.querySelectorAll(\"div.main-photo\");\n    const isVideo = videos.length > 0;\n    if (isVideo) {\n      window.open(url, \"_blank\");\n      return {};\n    }\n    // Search image if not video\n    const img = isVideo ? \"\" : doc.querySelectorAll(\"img.main-photo\")[0].src;\n    // const desc = doc.querySelectorAll(\"meta[name='description']\")[0]?.content\n    const desc = (_b = (_a = doc.querySelectorAll(\"div.title-desc-block.showFull\")[0].innerText) === null || _a === void 0 ? void 0 : _a.replace(\"Done\\n\\n\\t\", \"\")) === null || _b === void 0 ? void 0 : _b.trim();\n    // log(desc)\n    let description = desc;\n    let descriptionFull = \"\";\n    if ((desc === null || desc === void 0 ? void 0 : desc.length) > 200) {\n      description = desc.substring(0, 196) + \" ...\";\n      descriptionFull = desc;\n    }\n    // log(\"csrf\", window?.auth?.csrf)\n    // log(\"api_key\", window?.YUI_config?.flickr?.api?.site_key)\n    const csrf = (_c = window.auth) === null || _c === void 0 ? void 0 : _c.csrf;\n    const api_key = (_f = (_e = (_d = window.YUI_config) === null || _d === void 0 ? void 0 : _d.flickr) === null || _e === void 0 ? void 0 : _e.api) === null || _f === void 0 ? void 0 : _f.site_key;\n    const photo_id = url.split('/')[5];\n    const detailAPI = `https://api.flickr.com/services/rest?photo_id=${photo_id}&csrf=${csrf}&api_key=${api_key}&method=flickr.photos.getAllContexts&format=json&hermes=1&nojsoncallback=1`;\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.log)(\"detailAPI\", photo_id, detailAPI);\n    const detailRis = yield fetch(detailAPI, {\n      credentials: 'include'\n    });\n    const detailJson = yield detailRis.json();\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.log)(photo_id, JSON.stringify(detailJson));\n    // // log(doc.documentElement.outerHTML)\n    // // root.auth = {\"signedIn\":true,\"csrf\":\"1722138877:r29brohfedb:ddf6a30b05b02ddb3b5d3d6b16377ec2\"\n    // // document.documentElement.outerHTML.indexOf(\"api.site_key\")\n    // // root.YUI_config.flickr.api.site_key = \"dead99d0ecc6f9e26ce10b525a76d210\"\n    // // https://api.flickr.com/services/rest?photo_id=53885065640&method=flickr.photos.getAllContexts&csrf=1722136722%3Ahzvsu97ih4k%3Afb151e300b007170be037c7e34e0c09b&api_key=dead99d0ecc6f9e26ce10b525a76d210&format=json&hermes=1&nojsoncallback=1\n    // const sets = JSON.stringify(detailJson.set)\n    let album = \"\";\n    if (detailJson.set) {\n      (0,_utils__WEBPACK_IMPORTED_MODULE_0__.log)(detailJson.set);\n      const albums = detailJson.set.map(s => {\n        return {\n          id: s.id,\n          title: s.title,\n          owner: s.owner.nsid\n        };\n      });\n      const albumUrlTemplate = \"https://www.flickr.com/photos/$owner/albums/$id\";\n      albums.forEach(a => a.url = albumUrlTemplate.replace(\"$owner\", a.owner).replace(\"$id\", a.id));\n      // log(albums)\n      const albumLIst = albums.map(a => `<a href=\"${a.url}\">${a.title}</a>`);\n      (0,_utils__WEBPACK_IMPORTED_MODULE_0__.log)(\"album\", albumLIst, albumLIst.join(\"<br />\"));\n      album = albumLIst.join(\"<br />\");\n    }\n    const image = {\n      url: url,\n      img: img,\n      description: description,\n      descriptionFull: descriptionFull,\n      album: album,\n      photostream: {\n        name: photostreamName,\n        url: photostreamURL\n      }\n    };\n    return image;\n    // log(\"getImageInfo - end\", url)\n  });\n}\nfunction render(target, images) {\n  (0,_utils__WEBPACK_IMPORTED_MODULE_0__.log)(\"render\", images);\n  const template = `\n<div class=\"parent-container-rg\">\n    {{#images}}\n    <div title=\"{{descriptionFull}}\" class=\"child-container-rg\">\n\t\t<div class=\"photostream-rg\"><a href=\"{{photostream.url}}\">{{photostream.name}}</a></div>\n\t\t<div class=\"description-rg\">{{{description}}}</div>\n\t\t<div class=\"album-rg\">{{{album}}}</div>\n\t\t<a target=\"_blank\" href=\"{{url}}\">\n\t\t\t<img class=\"image-rg\" src=\"{{img}}\" />\n\t\t</a>\n    </div>\n    {{/images}}\n</div>\n\t`;\n  fill(template, target, images);\n}\nfunction getNewStyle() {\n  return `\n.parent-container-rg {\n    padding: 20px;\n}\n\na {\n    color: #FFFFFF;\n    font-weight: bold;\n}\n\n.image-rg {\n    height: 300px; \n}\n\n.child-container-rg {\n    float: left;\n    border: 1px solid #DDDDDD;\n    height: 300px; \n    position: relative;\n    /* width: 50%; */\n}\n\n.photostream-rg {\n    float: left;\n    position: absolute;\n    left: 0px;\n    top: 0px;\n    z-index: 1000;\n    background-color: rgba(146, 173, 64, 0.4);\n    padding: 5px;\n    color: #FFFFFF;\n    font-weight: bold;\n}\n\n.description-rg {\n    /* float: left; */\n    position: absolute;\n    left: 0px;\n    bottom: 0px;\n    z-index: 1000;\n    background-color: rgba(146, 173, 64, 0.4);\n    padding: 5px;\n    color: #FFFFFF;\n    font-weight: bold;\n}\n\n.album-rg {\n    float: right;\n    position: absolute;\n    right: 0px;\n    top: 0px;\n    z-index: 1000;\n    background-color: rgba(146, 173, 64, 0.4);\n    padding: 5px;\n    color: #FFFFFF;\n    font-weight: bold;\n}\n`;\n}\n\n//# sourceURL=webpack:///./public/loadPage.js?");

/***/ }),

/***/ "./public/utils.js":
/*!*************************!*\
  !*** ./public/utils.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getLocalStorage: () => (/* binding */ getLocalStorage),\n/* harmony export */   initLocalStorage: () => (/* binding */ initLocalStorage),\n/* harmony export */   log: () => (/* binding */ log),\n/* harmony export */   openTab: () => (/* binding */ openTab),\n/* harmony export */   setLocalStorage: () => (/* binding */ setLocalStorage)\n/* harmony export */ });\n/* harmony import */ var _content__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./content */ \"./public/content.js\");\nvar __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nfunction log(...msg) {\n  const date = new Date();\n  const logMsg = [_content__WEBPACK_IMPORTED_MODULE_0__.EXT_ID, \" - \", date.toLocaleDateString(), date.toLocaleTimeString(), \" - \", ...msg];\n  console.log(...logMsg);\n}\nfunction openTab(url) {\n  return __awaiter(this, void 0, void 0, function* () {\n    window.postMessage({\n      action: \"openTab\",\n      data: {\n        url: url\n      }\n    }, \"*\");\n  });\n}\nfunction setLocalStorage(key, value) {\n  localStorage.setItem(key, JSON.stringify(value));\n}\nfunction getLocalStorage(key) {\n  const value = localStorage.getItem(key);\n  if (value) {\n    return JSON.parse(value);\n  }\n  return null;\n}\nfunction initLocalStorage(key, initValue) {\n  if (!getLocalStorage(key)) {\n    setLocalStorage(key, initValue);\n  }\n}\n\n//# sourceURL=webpack:///./public/utils.js?");

/***/ }),

/***/ "./node_modules/mustache/mustache.mjs":
/*!********************************************!*\
  !*** ./node_modules/mustache/mustache.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\r\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\r\n * http://github.com/janl/mustache.js\r\n */\r\n\r\nvar objectToString = Object.prototype.toString;\r\nvar isArray = Array.isArray || function isArrayPolyfill (object) {\r\n  return objectToString.call(object) === '[object Array]';\r\n};\r\n\r\nfunction isFunction (object) {\r\n  return typeof object === 'function';\r\n}\r\n\r\n/**\r\n * More correct typeof string handling array\r\n * which normally returns typeof 'object'\r\n */\r\nfunction typeStr (obj) {\r\n  return isArray(obj) ? 'array' : typeof obj;\r\n}\r\n\r\nfunction escapeRegExp (string) {\r\n  return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&');\r\n}\r\n\r\n/**\r\n * Null safe way of checking whether or not an object,\r\n * including its prototype, has a given property\r\n */\r\nfunction hasProperty (obj, propName) {\r\n  return obj != null && typeof obj === 'object' && (propName in obj);\r\n}\r\n\r\n/**\r\n * Safe way of detecting whether or not the given thing is a primitive and\r\n * whether it has the given property\r\n */\r\nfunction primitiveHasOwnProperty (primitive, propName) {\r\n  return (\r\n    primitive != null\r\n    && typeof primitive !== 'object'\r\n    && primitive.hasOwnProperty\r\n    && primitive.hasOwnProperty(propName)\r\n  );\r\n}\r\n\r\n// Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\r\n// See https://github.com/janl/mustache.js/issues/189\r\nvar regExpTest = RegExp.prototype.test;\r\nfunction testRegExp (re, string) {\r\n  return regExpTest.call(re, string);\r\n}\r\n\r\nvar nonSpaceRe = /\\S/;\r\nfunction isWhitespace (string) {\r\n  return !testRegExp(nonSpaceRe, string);\r\n}\r\n\r\nvar entityMap = {\r\n  '&': '&amp;',\r\n  '<': '&lt;',\r\n  '>': '&gt;',\r\n  '\"': '&quot;',\r\n  \"'\": '&#39;',\r\n  '/': '&#x2F;',\r\n  '`': '&#x60;',\r\n  '=': '&#x3D;'\r\n};\r\n\r\nfunction escapeHtml (string) {\r\n  return String(string).replace(/[&<>\"'`=\\/]/g, function fromEntityMap (s) {\r\n    return entityMap[s];\r\n  });\r\n}\r\n\r\nvar whiteRe = /\\s*/;\r\nvar spaceRe = /\\s+/;\r\nvar equalsRe = /\\s*=/;\r\nvar curlyRe = /\\s*\\}/;\r\nvar tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\r\n\r\n/**\r\n * Breaks up the given `template` string into a tree of tokens. If the `tags`\r\n * argument is given here it must be an array with two string values: the\r\n * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\r\n * course, the default is to use mustaches (i.e. mustache.tags).\r\n *\r\n * A token is an array with at least 4 elements. The first element is the\r\n * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\r\n * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\r\n * all text that appears outside a symbol this element is \"text\".\r\n *\r\n * The second element of a token is its \"value\". For mustache tags this is\r\n * whatever else was inside the tag besides the opening symbol. For text tokens\r\n * this is the text itself.\r\n *\r\n * The third and fourth elements of the token are the start and end indices,\r\n * respectively, of the token in the original template.\r\n *\r\n * Tokens that are the root node of a subtree contain two more elements: 1) an\r\n * array of tokens in the subtree and 2) the index in the original template at\r\n * which the closing tag for that section begins.\r\n *\r\n * Tokens for partials also contain two more elements: 1) a string value of\r\n * indendation prior to that tag and 2) the index of that tag on that line -\r\n * eg a value of 2 indicates the partial is the third tag on this line.\r\n */\r\nfunction parseTemplate (template, tags) {\r\n  if (!template)\r\n    return [];\r\n  var lineHasNonSpace = false;\r\n  var sections = [];     // Stack to hold section tokens\r\n  var tokens = [];       // Buffer to hold the tokens\r\n  var spaces = [];       // Indices of whitespace tokens on the current line\r\n  var hasTag = false;    // Is there a {{tag}} on the current line?\r\n  var nonSpace = false;  // Is there a non-space char on the current line?\r\n  var indentation = '';  // Tracks indentation for tags that use it\r\n  var tagIndex = 0;      // Stores a count of number of tags encountered on a line\r\n\r\n  // Strips all whitespace tokens array for the current line\r\n  // if there was a {{#tag}} on it and otherwise only space.\r\n  function stripSpace () {\r\n    if (hasTag && !nonSpace) {\r\n      while (spaces.length)\r\n        delete tokens[spaces.pop()];\r\n    } else {\r\n      spaces = [];\r\n    }\r\n\r\n    hasTag = false;\r\n    nonSpace = false;\r\n  }\r\n\r\n  var openingTagRe, closingTagRe, closingCurlyRe;\r\n  function compileTags (tagsToCompile) {\r\n    if (typeof tagsToCompile === 'string')\r\n      tagsToCompile = tagsToCompile.split(spaceRe, 2);\r\n\r\n    if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)\r\n      throw new Error('Invalid tags: ' + tagsToCompile);\r\n\r\n    openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\\\s*');\r\n    closingTagRe = new RegExp('\\\\s*' + escapeRegExp(tagsToCompile[1]));\r\n    closingCurlyRe = new RegExp('\\\\s*' + escapeRegExp('}' + tagsToCompile[1]));\r\n  }\r\n\r\n  compileTags(tags || mustache.tags);\r\n\r\n  var scanner = new Scanner(template);\r\n\r\n  var start, type, value, chr, token, openSection;\r\n  while (!scanner.eos()) {\r\n    start = scanner.pos;\r\n\r\n    // Match any text between tags.\r\n    value = scanner.scanUntil(openingTagRe);\r\n\r\n    if (value) {\r\n      for (var i = 0, valueLength = value.length; i < valueLength; ++i) {\r\n        chr = value.charAt(i);\r\n\r\n        if (isWhitespace(chr)) {\r\n          spaces.push(tokens.length);\r\n          indentation += chr;\r\n        } else {\r\n          nonSpace = true;\r\n          lineHasNonSpace = true;\r\n          indentation += ' ';\r\n        }\r\n\r\n        tokens.push([ 'text', chr, start, start + 1 ]);\r\n        start += 1;\r\n\r\n        // Check for whitespace on the current line.\r\n        if (chr === '\\n') {\r\n          stripSpace();\r\n          indentation = '';\r\n          tagIndex = 0;\r\n          lineHasNonSpace = false;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Match the opening tag.\r\n    if (!scanner.scan(openingTagRe))\r\n      break;\r\n\r\n    hasTag = true;\r\n\r\n    // Get the tag type.\r\n    type = scanner.scan(tagRe) || 'name';\r\n    scanner.scan(whiteRe);\r\n\r\n    // Get the tag value.\r\n    if (type === '=') {\r\n      value = scanner.scanUntil(equalsRe);\r\n      scanner.scan(equalsRe);\r\n      scanner.scanUntil(closingTagRe);\r\n    } else if (type === '{') {\r\n      value = scanner.scanUntil(closingCurlyRe);\r\n      scanner.scan(curlyRe);\r\n      scanner.scanUntil(closingTagRe);\r\n      type = '&';\r\n    } else {\r\n      value = scanner.scanUntil(closingTagRe);\r\n    }\r\n\r\n    // Match the closing tag.\r\n    if (!scanner.scan(closingTagRe))\r\n      throw new Error('Unclosed tag at ' + scanner.pos);\r\n\r\n    if (type == '>') {\r\n      token = [ type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace ];\r\n    } else {\r\n      token = [ type, value, start, scanner.pos ];\r\n    }\r\n    tagIndex++;\r\n    tokens.push(token);\r\n\r\n    if (type === '#' || type === '^') {\r\n      sections.push(token);\r\n    } else if (type === '/') {\r\n      // Check section nesting.\r\n      openSection = sections.pop();\r\n\r\n      if (!openSection)\r\n        throw new Error('Unopened section \"' + value + '\" at ' + start);\r\n\r\n      if (openSection[1] !== value)\r\n        throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\r\n    } else if (type === 'name' || type === '{' || type === '&') {\r\n      nonSpace = true;\r\n    } else if (type === '=') {\r\n      // Set the tags for the next time around.\r\n      compileTags(value);\r\n    }\r\n  }\r\n\r\n  stripSpace();\r\n\r\n  // Make sure there are no open sections when we're done.\r\n  openSection = sections.pop();\r\n\r\n  if (openSection)\r\n    throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\r\n\r\n  return nestTokens(squashTokens(tokens));\r\n}\r\n\r\n/**\r\n * Combines the values of consecutive text tokens in the given `tokens` array\r\n * to a single token.\r\n */\r\nfunction squashTokens (tokens) {\r\n  var squashedTokens = [];\r\n\r\n  var token, lastToken;\r\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\r\n    token = tokens[i];\r\n\r\n    if (token) {\r\n      if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\r\n        lastToken[1] += token[1];\r\n        lastToken[3] = token[3];\r\n      } else {\r\n        squashedTokens.push(token);\r\n        lastToken = token;\r\n      }\r\n    }\r\n  }\r\n\r\n  return squashedTokens;\r\n}\r\n\r\n/**\r\n * Forms the given array of `tokens` into a nested tree structure where\r\n * tokens that represent a section have two additional items: 1) an array of\r\n * all tokens that appear in that section and 2) the index in the original\r\n * template that represents the end of that section.\r\n */\r\nfunction nestTokens (tokens) {\r\n  var nestedTokens = [];\r\n  var collector = nestedTokens;\r\n  var sections = [];\r\n\r\n  var token, section;\r\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\r\n    token = tokens[i];\r\n\r\n    switch (token[0]) {\r\n      case '#':\r\n      case '^':\r\n        collector.push(token);\r\n        sections.push(token);\r\n        collector = token[4] = [];\r\n        break;\r\n      case '/':\r\n        section = sections.pop();\r\n        section[5] = token[2];\r\n        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\r\n        break;\r\n      default:\r\n        collector.push(token);\r\n    }\r\n  }\r\n\r\n  return nestedTokens;\r\n}\r\n\r\n/**\r\n * A simple string scanner that is used by the template parser to find\r\n * tokens in template strings.\r\n */\r\nfunction Scanner (string) {\r\n  this.string = string;\r\n  this.tail = string;\r\n  this.pos = 0;\r\n}\r\n\r\n/**\r\n * Returns `true` if the tail is empty (end of string).\r\n */\r\nScanner.prototype.eos = function eos () {\r\n  return this.tail === '';\r\n};\r\n\r\n/**\r\n * Tries to match the given regular expression at the current position.\r\n * Returns the matched text if it can match, the empty string otherwise.\r\n */\r\nScanner.prototype.scan = function scan (re) {\r\n  var match = this.tail.match(re);\r\n\r\n  if (!match || match.index !== 0)\r\n    return '';\r\n\r\n  var string = match[0];\r\n\r\n  this.tail = this.tail.substring(string.length);\r\n  this.pos += string.length;\r\n\r\n  return string;\r\n};\r\n\r\n/**\r\n * Skips all text until the given regular expression can be matched. Returns\r\n * the skipped string, which is the entire tail if no match can be made.\r\n */\r\nScanner.prototype.scanUntil = function scanUntil (re) {\r\n  var index = this.tail.search(re), match;\r\n\r\n  switch (index) {\r\n    case -1:\r\n      match = this.tail;\r\n      this.tail = '';\r\n      break;\r\n    case 0:\r\n      match = '';\r\n      break;\r\n    default:\r\n      match = this.tail.substring(0, index);\r\n      this.tail = this.tail.substring(index);\r\n  }\r\n\r\n  this.pos += match.length;\r\n\r\n  return match;\r\n};\r\n\r\n/**\r\n * Represents a rendering context by wrapping a view object and\r\n * maintaining a reference to the parent context.\r\n */\r\nfunction Context (view, parentContext) {\r\n  this.view = view;\r\n  this.cache = { '.': this.view };\r\n  this.parent = parentContext;\r\n}\r\n\r\n/**\r\n * Creates a new context using the given view with this context\r\n * as the parent.\r\n */\r\nContext.prototype.push = function push (view) {\r\n  return new Context(view, this);\r\n};\r\n\r\n/**\r\n * Returns the value of the given name in this context, traversing\r\n * up the context hierarchy if the value is absent in this context's view.\r\n */\r\nContext.prototype.lookup = function lookup (name) {\r\n  var cache = this.cache;\r\n\r\n  var value;\r\n  if (cache.hasOwnProperty(name)) {\r\n    value = cache[name];\r\n  } else {\r\n    var context = this, intermediateValue, names, index, lookupHit = false;\r\n\r\n    while (context) {\r\n      if (name.indexOf('.') > 0) {\r\n        intermediateValue = context.view;\r\n        names = name.split('.');\r\n        index = 0;\r\n\r\n        /**\r\n         * Using the dot notion path in `name`, we descend through the\r\n         * nested objects.\r\n         *\r\n         * To be certain that the lookup has been successful, we have to\r\n         * check if the last object in the path actually has the property\r\n         * we are looking for. We store the result in `lookupHit`.\r\n         *\r\n         * This is specially necessary for when the value has been set to\r\n         * `undefined` and we want to avoid looking up parent contexts.\r\n         *\r\n         * In the case where dot notation is used, we consider the lookup\r\n         * to be successful even if the last \"object\" in the path is\r\n         * not actually an object but a primitive (e.g., a string, or an\r\n         * integer), because it is sometimes useful to access a property\r\n         * of an autoboxed primitive, such as the length of a string.\r\n         **/\r\n        while (intermediateValue != null && index < names.length) {\r\n          if (index === names.length - 1)\r\n            lookupHit = (\r\n              hasProperty(intermediateValue, names[index])\r\n              || primitiveHasOwnProperty(intermediateValue, names[index])\r\n            );\r\n\r\n          intermediateValue = intermediateValue[names[index++]];\r\n        }\r\n      } else {\r\n        intermediateValue = context.view[name];\r\n\r\n        /**\r\n         * Only checking against `hasProperty`, which always returns `false` if\r\n         * `context.view` is not an object. Deliberately omitting the check\r\n         * against `primitiveHasOwnProperty` if dot notation is not used.\r\n         *\r\n         * Consider this example:\r\n         * ```\r\n         * Mustache.render(\"The length of a football field is {{#length}}{{length}}{{/length}}.\", {length: \"100 yards\"})\r\n         * ```\r\n         *\r\n         * If we were to check also against `primitiveHasOwnProperty`, as we do\r\n         * in the dot notation case, then render call would return:\r\n         *\r\n         * \"The length of a football field is 9.\"\r\n         *\r\n         * rather than the expected:\r\n         *\r\n         * \"The length of a football field is 100 yards.\"\r\n         **/\r\n        lookupHit = hasProperty(context.view, name);\r\n      }\r\n\r\n      if (lookupHit) {\r\n        value = intermediateValue;\r\n        break;\r\n      }\r\n\r\n      context = context.parent;\r\n    }\r\n\r\n    cache[name] = value;\r\n  }\r\n\r\n  if (isFunction(value))\r\n    value = value.call(this.view);\r\n\r\n  return value;\r\n};\r\n\r\n/**\r\n * A Writer knows how to take a stream of tokens and render them to a\r\n * string, given a context. It also maintains a cache of templates to\r\n * avoid the need to parse the same template twice.\r\n */\r\nfunction Writer () {\r\n  this.templateCache = {\r\n    _cache: {},\r\n    set: function set (key, value) {\r\n      this._cache[key] = value;\r\n    },\r\n    get: function get (key) {\r\n      return this._cache[key];\r\n    },\r\n    clear: function clear () {\r\n      this._cache = {};\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Clears all cached templates in this writer.\r\n */\r\nWriter.prototype.clearCache = function clearCache () {\r\n  if (typeof this.templateCache !== 'undefined') {\r\n    this.templateCache.clear();\r\n  }\r\n};\r\n\r\n/**\r\n * Parses and caches the given `template` according to the given `tags` or\r\n * `mustache.tags` if `tags` is omitted,  and returns the array of tokens\r\n * that is generated from the parse.\r\n */\r\nWriter.prototype.parse = function parse (template, tags) {\r\n  var cache = this.templateCache;\r\n  var cacheKey = template + ':' + (tags || mustache.tags).join(':');\r\n  var isCacheEnabled = typeof cache !== 'undefined';\r\n  var tokens = isCacheEnabled ? cache.get(cacheKey) : undefined;\r\n\r\n  if (tokens == undefined) {\r\n    tokens = parseTemplate(template, tags);\r\n    isCacheEnabled && cache.set(cacheKey, tokens);\r\n  }\r\n  return tokens;\r\n};\r\n\r\n/**\r\n * High-level method that is used to render the given `template` with\r\n * the given `view`.\r\n *\r\n * The optional `partials` argument may be an object that contains the\r\n * names and templates of partials that are used in the template. It may\r\n * also be a function that is used to load partial templates on the fly\r\n * that takes a single argument: the name of the partial.\r\n *\r\n * If the optional `config` argument is given here, then it should be an\r\n * object with a `tags` attribute or an `escape` attribute or both.\r\n * If an array is passed, then it will be interpreted the same way as\r\n * a `tags` attribute on a `config` object.\r\n *\r\n * The `tags` attribute of a `config` object must be an array with two\r\n * string values: the opening and closing tags used in the template (e.g.\r\n * [ \"<%\", \"%>\" ]). The default is to mustache.tags.\r\n *\r\n * The `escape` attribute of a `config` object must be a function which\r\n * accepts a string as input and outputs a safely escaped string.\r\n * If an `escape` function is not provided, then an HTML-safe string\r\n * escaping function is used as the default.\r\n */\r\nWriter.prototype.render = function render (template, view, partials, config) {\r\n  var tags = this.getConfigTags(config);\r\n  var tokens = this.parse(template, tags);\r\n  var context = (view instanceof Context) ? view : new Context(view, undefined);\r\n  return this.renderTokens(tokens, context, partials, template, config);\r\n};\r\n\r\n/**\r\n * Low-level method that renders the given array of `tokens` using\r\n * the given `context` and `partials`.\r\n *\r\n * Note: The `originalTemplate` is only ever used to extract the portion\r\n * of the original template that was contained in a higher-order section.\r\n * If the template doesn't use higher-order sections, this argument may\r\n * be omitted.\r\n */\r\nWriter.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate, config) {\r\n  var buffer = '';\r\n\r\n  var token, symbol, value;\r\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\r\n    value = undefined;\r\n    token = tokens[i];\r\n    symbol = token[0];\r\n\r\n    if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate, config);\r\n    else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate, config);\r\n    else if (symbol === '>') value = this.renderPartial(token, context, partials, config);\r\n    else if (symbol === '&') value = this.unescapedValue(token, context);\r\n    else if (symbol === 'name') value = this.escapedValue(token, context, config);\r\n    else if (symbol === 'text') value = this.rawValue(token);\r\n\r\n    if (value !== undefined)\r\n      buffer += value;\r\n  }\r\n\r\n  return buffer;\r\n};\r\n\r\nWriter.prototype.renderSection = function renderSection (token, context, partials, originalTemplate, config) {\r\n  var self = this;\r\n  var buffer = '';\r\n  var value = context.lookup(token[1]);\r\n\r\n  // This function is used to render an arbitrary template\r\n  // in the current context by higher-order sections.\r\n  function subRender (template) {\r\n    return self.render(template, context, partials, config);\r\n  }\r\n\r\n  if (!value) return;\r\n\r\n  if (isArray(value)) {\r\n    for (var j = 0, valueLength = value.length; j < valueLength; ++j) {\r\n      buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);\r\n    }\r\n  } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {\r\n    buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);\r\n  } else if (isFunction(value)) {\r\n    if (typeof originalTemplate !== 'string')\r\n      throw new Error('Cannot use higher-order sections without the original template');\r\n\r\n    // Extract the portion of the original template that the section contains.\r\n    value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\r\n\r\n    if (value != null)\r\n      buffer += value;\r\n  } else {\r\n    buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);\r\n  }\r\n  return buffer;\r\n};\r\n\r\nWriter.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate, config) {\r\n  var value = context.lookup(token[1]);\r\n\r\n  // Use JavaScript's definition of falsy. Include empty arrays.\r\n  // See https://github.com/janl/mustache.js/issues/186\r\n  if (!value || (isArray(value) && value.length === 0))\r\n    return this.renderTokens(token[4], context, partials, originalTemplate, config);\r\n};\r\n\r\nWriter.prototype.indentPartial = function indentPartial (partial, indentation, lineHasNonSpace) {\r\n  var filteredIndentation = indentation.replace(/[^ \\t]/g, '');\r\n  var partialByNl = partial.split('\\n');\r\n  for (var i = 0; i < partialByNl.length; i++) {\r\n    if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {\r\n      partialByNl[i] = filteredIndentation + partialByNl[i];\r\n    }\r\n  }\r\n  return partialByNl.join('\\n');\r\n};\r\n\r\nWriter.prototype.renderPartial = function renderPartial (token, context, partials, config) {\r\n  if (!partials) return;\r\n  var tags = this.getConfigTags(config);\r\n\r\n  var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\r\n  if (value != null) {\r\n    var lineHasNonSpace = token[6];\r\n    var tagIndex = token[5];\r\n    var indentation = token[4];\r\n    var indentedValue = value;\r\n    if (tagIndex == 0 && indentation) {\r\n      indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);\r\n    }\r\n    var tokens = this.parse(indentedValue, tags);\r\n    return this.renderTokens(tokens, context, partials, indentedValue, config);\r\n  }\r\n};\r\n\r\nWriter.prototype.unescapedValue = function unescapedValue (token, context) {\r\n  var value = context.lookup(token[1]);\r\n  if (value != null)\r\n    return value;\r\n};\r\n\r\nWriter.prototype.escapedValue = function escapedValue (token, context, config) {\r\n  var escape = this.getConfigEscape(config) || mustache.escape;\r\n  var value = context.lookup(token[1]);\r\n  if (value != null)\r\n    return (typeof value === 'number' && escape === mustache.escape) ? String(value) : escape(value);\r\n};\r\n\r\nWriter.prototype.rawValue = function rawValue (token) {\r\n  return token[1];\r\n};\r\n\r\nWriter.prototype.getConfigTags = function getConfigTags (config) {\r\n  if (isArray(config)) {\r\n    return config;\r\n  }\r\n  else if (config && typeof config === 'object') {\r\n    return config.tags;\r\n  }\r\n  else {\r\n    return undefined;\r\n  }\r\n};\r\n\r\nWriter.prototype.getConfigEscape = function getConfigEscape (config) {\r\n  if (config && typeof config === 'object' && !isArray(config)) {\r\n    return config.escape;\r\n  }\r\n  else {\r\n    return undefined;\r\n  }\r\n};\r\n\r\nvar mustache = {\r\n  name: 'mustache.js',\r\n  version: '4.2.0',\r\n  tags: [ '{{', '}}' ],\r\n  clearCache: undefined,\r\n  escape: undefined,\r\n  parse: undefined,\r\n  render: undefined,\r\n  Scanner: undefined,\r\n  Context: undefined,\r\n  Writer: undefined,\r\n  /**\r\n   * Allows a user to override the default caching strategy, by providing an\r\n   * object with set, get and clear methods. This can also be used to disable\r\n   * the cache by setting it to the literal `undefined`.\r\n   */\r\n  set templateCache (cache) {\r\n    defaultWriter.templateCache = cache;\r\n  },\r\n  /**\r\n   * Gets the default or overridden caching object from the default writer.\r\n   */\r\n  get templateCache () {\r\n    return defaultWriter.templateCache;\r\n  }\r\n};\r\n\r\n// All high-level mustache.* functions use this writer.\r\nvar defaultWriter = new Writer();\r\n\r\n/**\r\n * Clears all cached templates in the default writer.\r\n */\r\nmustache.clearCache = function clearCache () {\r\n  return defaultWriter.clearCache();\r\n};\r\n\r\n/**\r\n * Parses and caches the given template in the default writer and returns the\r\n * array of tokens it contains. Doing this ahead of time avoids the need to\r\n * parse templates on the fly as they are rendered.\r\n */\r\nmustache.parse = function parse (template, tags) {\r\n  return defaultWriter.parse(template, tags);\r\n};\r\n\r\n/**\r\n * Renders the `template` with the given `view`, `partials`, and `config`\r\n * using the default writer.\r\n */\r\nmustache.render = function render (template, view, partials, config) {\r\n  if (typeof template !== 'string') {\r\n    throw new TypeError('Invalid template! Template should be a \"string\" ' +\r\n                        'but \"' + typeStr(template) + '\" was given as the first ' +\r\n                        'argument for mustache#render(template, view, partials)');\r\n  }\r\n\r\n  return defaultWriter.render(template, view, partials, config);\r\n};\r\n\r\n// Export the escaping function so that the user may override it.\r\n// See https://github.com/janl/mustache.js/issues/244\r\nmustache.escape = escapeHtml;\r\n\r\n// Export these mainly for testing, but also for advanced usage.\r\nmustache.Scanner = Scanner;\r\nmustache.Context = Context;\r\nmustache.Writer = Writer;\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mustache);\r\n\n\n//# sourceURL=webpack:///./node_modules/mustache/mustache.mjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./public/content.js");
/******/ 	
/******/ })()
;